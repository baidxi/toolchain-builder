--- a/gcc/config/mips/mips.c
+++ b/gcc/config/mips/mips.c
@@ -7986,6 +7986,8 @@ mips_block_move_straight (rtx dest, rtx
       if (MEM_ALIGN (src) == BITS_PER_WORD / 2
 	  && MEM_ALIGN (dest) == BITS_PER_WORD / 2)
 	bits = BITS_PER_WORD / 2;
+      else if (TARGET_LEXRA || TARGET_RLX)
+        bits = MIN (MEM_ALIGN (src), MEM_ALIGN (dest));
       else
 	bits = BITS_PER_WORD;
     }
@@ -8361,6 +8363,8 @@ mips_expand_ext_as_unaligned_load (rtx d
     }
   else
     {
+      if (TARGET_LEXRA || TARGET_RLX)
+        return false;
       emit_insn (gen_mov_lwl (temp, src, left));
       emit_insn (gen_mov_lwr (dest, copy_rtx (src), right, temp));
     }
@@ -8404,6 +8408,8 @@ mips_expand_ins_as_unaligned_store (rtx
     }
   else
     {
+      if (TARGET_LEXRA || TARGET_RLX)
+        return false;
       emit_insn (gen_mov_swl (dest, src, left));
       emit_insn (gen_mov_swr (copy_rtx (dest), copy_rtx (src), right));
     }
@@ -19663,6 +19669,10 @@ mips_option_override (void)
   if (mips_arch_info == 0)
     mips_set_architecture (mips_default_arch ());
 
+  /* flag_fix_bdsl only works for Taroko processors */
+  if (flag_fix_bdsl && !(TARGET_LEXRA || TARGET_RLX))
+    flag_fix_bdsl = false;
+
   if (ABI_NEEDS_64BIT_REGS && !ISA_HAS_64BIT_REGS)
     error ("%<-march=%s%> is not compatible with the selected ABI",
 	   mips_arch_info->name);
--- a/gcc/config/mips/mips-cpus.def
+++ b/gcc/config/mips/mips-cpus.def
@@ -171,3 +171,11 @@ MIPS_CPU ("xlp", PROCESSOR_XLP, 65, PTF_
 
 /* MIPS64 Release 6 processors.  */
 MIPS_CPU ("i6400", PROCESSOR_I6400, 69, 0)
+
+/* Lexra processors */
+MIPS_CPU ("lx4180", PROCESSOR_LX4180, 1, 0)
+MIPS_CPU ("rlx4181", PROCESSOR_RLX4181, 1, 0)
+MIPS_CPU ("rlx4281", PROCESSOR_RLX4281, 1, 0)
+MIPS_CPU ("rlx5181", PROCESSOR_RLX5181, 1, 0)
+MIPS_CPU ("lx5280", PROCESSOR_LX5280, 1, 0)
+MIPS_CPU ("rlx5281", PROCESSOR_RLX5281, 1, 0)
--- a/gcc/config/mips/mips.h
+++ b/gcc/config/mips/mips.h
@@ -287,6 +287,16 @@ struct mips_cpu_info {
 #define TARGET_SR71K                (mips_arch == PROCESSOR_SR71000)
 #define TARGET_XLP                  (mips_arch == PROCESSOR_XLP)
 
+#define TARGET_LX4180		    (mips_arch == PROCESSOR_LX4180)
+#define TARGET_RLX4181		    (mips_arch == PROCESSOR_RLX4181)
+#define TARGET_RLX4281		    (mips_arch == PROCESSOR_RLX4281)
+#define TARGET_RLX5181		    (mips_arch == PROCESSOR_RLX5181)
+#define TARGET_LX5280		    (mips_arch == PROCESSOR_LX5280)
+#define TARGET_RLX5281		    (mips_arch == PROCESSOR_RLX5281)
+#define TARGET_RLX		    (TARGET_LX4180 || TARGET_RLX4181	\
+				     || TARGET_RLX4281 || TARGET_RLX5181 \
+				     || TARGET_LX5280 || TARGET_RLX5281)
+
 /* Scheduling target defines.  */
 #define TUNE_20KC		    (mips_tune == PROCESSOR_20KC)
 #define TUNE_24K		    (mips_tune == PROCESSOR_24KC	\
@@ -299,7 +309,7 @@ struct mips_cpu_info {
 #define TUNE_LOONGSON_2EF           (mips_tune == PROCESSOR_LOONGSON_2E	\
 				     || mips_tune == PROCESSOR_LOONGSON_2F)
 #define TUNE_LOONGSON_3A            (mips_tune == PROCESSOR_LOONGSON_3A)
-#define TUNE_MIPS3000               (mips_tune == PROCESSOR_R3000)
+#define TUNE_MIPS3000               (mips_tune == PROCESSOR_R3000 || TUNE_RLX)
 #define TUNE_MIPS3900               (mips_tune == PROCESSOR_R3900)
 #define TUNE_MIPS4000               (mips_tune == PROCESSOR_R4000)
 #define TUNE_MIPS4120               (mips_tune == PROCESSOR_R4120)
@@ -318,6 +328,29 @@ struct mips_cpu_info {
 #define TUNE_P5600                  (mips_tune == PROCESSOR_P5600)
 #define TUNE_I6400                  (mips_tune == PROCESSOR_I6400)
 
+#define TUNE_LX4180		    (mips_tune == PROCESSOR_LX4180)
+#define TUNE_RLX4181		    (mips_tune == PROCESSOR_RLX4181)
+#define TUNE_RLX4281		    (mips_tune == PROCESSOR_RLX4281)
+#define TUNE_RLX5181		    (mips_tune == PROCESSOR_RLX5181)
+#define TUNE_LX5280		    (mips_tune == PROCESSOR_LX5280)
+#define TUNE_RLX5281		    (mips_tune == PROCESSOR_RLX5281)
+#define TUNE_RLX		    (TUNE_LX4180 || TUNE_RLX4181	\
+				     || TUNE_RLX4281 || TUNE_RLX4181	\
+				     || TUNE_LX5280 || TUNE_RLX5281)
+
+/* Instruction-set for Lexra defines. */
+#define INSN_RLX0		    (TARGET_LX4180)
+#define INSN_RLX1		    (TARGET_LX5280)
+#define INSN_RLX2		    (TARGET_RLX4181 || TARGET_RLX5181)
+#define INSN_RLX3		    (TARGET_RLX4281 || TARGET_RLX5281)
+
+#define INSN_RLXA		    (INSN_RLX0 || INSN_RLX1 || INSN_RLX2 \
+				     || INSN_RLX3)
+#define INSN_RLXB		    (INSN_RLX1 || INSN_RLX2 || INSN_RLX3)
+
+#define INSN_RAD1		    (INSN_5181 || INSN_5280 || INSN_5281)
+#define INSN_RAD2		    (INSN_5281)
+
 /* Whether vector modes and intrinsics for ST Microelectronics
    Loongson-2E/2F processors should be enabled.  In o32 pairs of
    floating-point registers provide 64-bit values.  */
@@ -641,6 +674,26 @@ struct mips_cpu_info {
 	builtin_define ("__mips_no_lxc1_sxc1");				\
       if (!ISA_HAS_UNFUSED_MADD4 && !ISA_HAS_FUSED_MADD4)		\
 	builtin_define ("__mips_no_madd4");				\
+									\
+      if (TARGET_LX4180)						\
+	builtin_define ("__m4180");					\
+      else if (TARGET_RLX4181)						\
+	builtin_define ("__m4181");					\
+      else if (TARGET_RLX4281)						\
+	builtin_define ("__m4281");					\
+      else if (TARGET_RLX5181)						\
+	builtin_define ("__m5181");					\
+      else if (TARGET_LX5280)						\
+	builtin_define ("__m5280");					\
+      else if (TARGET_RLX5281)						\
+	builtin_define ("__m5281");					\
+									\
+      if (TARGET_LEXRA || TARGET_RLX)					\
+	builtin_define ("__mlexra");					\
+									\
+      if (flag_fix_bdsl)						\
+	builtin_define ("__FIX_BDSL__");				\
+									\
     }									\
   while (0)
 
@@ -799,6 +852,8 @@ struct mips_cpu_info {
   "%{mhard-float|msoft-float|mno-float|march=mips*:; \
      march=vr41*|march=m4k|march=4k*|march=24kc|march=24kec \
      |march=34kc|march=34kn|march=74kc|march=1004kc|march=5kc \
+     |march=lx4180|march=rlx4181|march=rlx4281|march=rlx5181 \
+     |march=lx5280|march=rlx5281 \
      |march=m14k*|march=m5101|march=octeon|march=xlr: -msoft-float; \
      march=*: -mhard-float}"
 
@@ -1011,7 +1066,8 @@ struct mips_cpu_info {
    ST Loongson 2E/2F.  */
 #define ISA_HAS_CONDMOVE        (ISA_HAS_FP_CONDMOVE			\
 				 || TARGET_MIPS5900			\
-				 || TARGET_LOONGSON_2EF)
+				 || TARGET_LOONGSON_2EF \
+                                 || (!TARGET_MIPS16 && INSN_RLXB))
 
 /* ISA has LDC1 and SDC1.  */
 #define ISA_HAS_LDC1_SDC1	(!ISA_MIPS1				\
@@ -1105,7 +1161,8 @@ struct mips_cpu_info {
 				      && (MODE) == V2SFmode))		\
 				 && !TARGET_MIPS16)
 
-#define ISA_HAS_LWL_LWR		(mips_isa_rev <= 5 && !TARGET_MIPS16)
+#define ISA_HAS_LWL_LWR		(mips_isa_rev <= 5 && !(TARGET_RLX || \
+				 TARGET_LEXRA) && !TARGET_MIPS16)
 
 #define ISA_HAS_IEEE_754_LEGACY	(mips_isa_rev <= 5)
 
@@ -1255,7 +1312,8 @@ struct mips_cpu_info {
 #define ISA_HAS_SYNCI (mips_isa_rev >= 2 && !TARGET_MIPS16)
 
 /* ISA includes sync.  */
-#define ISA_HAS_SYNC ((mips_isa >= 2 || TARGET_MIPS3900) && !TARGET_MIPS16)
+#define ISA_HAS_SYNC ((mips_isa >= 2 || TARGET_MIPS3900 || INSN_RLX3)	\
+		      && !TARGET_MIPS16)
 #define GENERATE_SYNC			\
   (target_flags_explicit & MASK_LLSC	\
    ? TARGET_LLSC && !TARGET_MIPS16	\
@@ -1264,7 +1322,8 @@ struct mips_cpu_info {
 /* ISA includes ll and sc.  Note that this implies ISA_HAS_SYNC
    because the expanders use both ISA_HAS_SYNC and ISA_HAS_LL_SC
    instructions.  */
-#define ISA_HAS_LL_SC (mips_isa >= 2 && !TARGET_MIPS5900 && !TARGET_MIPS16)
+#define ISA_HAS_LL_SC ((mips_isa >= 2 || INSN_RLX3) && !TARGET_MIPS5900 \
+			&& !TARGET_MIPS16)
 #define GENERATE_LL_SC			\
   (target_flags_explicit & MASK_LLSC	\
    ? TARGET_LLSC && !TARGET_MIPS16	\
@@ -1396,6 +1455,12 @@ FP_ASM_SPEC "\
 
 #undef CC1_SPEC
 #define CC1_SPEC "\
+%{mlx4180:-march=lx4180} \
+%{mrlx4181:-march=rlx4181} \
+%{mrlx4281:-march=rlx4281} \
+%{mrlx5181:-march=rlx5181} \
+%{mlx5280:-march=lx5280} \
+%{mrlx5281:-march=rlx5281} \
 %{G*} %{EB:-meb} %{EL:-mel} %{EB:%{EL:%emay not use both -EB and -EL}} \
 %(subtarget_cc1_spec)"
 
--- a/gcc/config/mips/mips.md
+++ b/gcc/config/mips/mips.md
@@ -69,6 +69,12 @@
   p5600
   m5100
   i6400
+  lx4180
+  rlx4181
+  rlx4281
+  rlx5181
+  lx5280
+  rlx5281
 ])
 
 (define_c_enum "unspec" [
@@ -757,9 +763,13 @@
 
 ;; Can the instruction be put into a delay slot?
 (define_attr "can_delay" "no,yes"
-  (if_then_else (and (eq_attr "type" "!branch,call,jump")
-		     (eq_attr "hazard" "none")
-		     (match_test "get_attr_insn_count (insn) == 1"))
+  (if_then_else (and (ior (eq (symbol_ref "TARGET_MIPS16") (const_int 0))
+			  (eq (symbol_ref "flag_fix_bdsl") (const_int 0)))
+		     (ior (eq_attr "type" "!load")
+			  (eq (symbol_ref "flag_fix_bdsl") (const_int 0)))
+		     (and (eq_attr "type" "!branch,call,jump")
+			  (and (eq_attr "hazard" "none")
+			       (match_test "get_attr_insn_count (insn) == 1"))))
 		(const_string "yes")
 		(const_string "no")))
 
@@ -4339,7 +4349,7 @@
 	(unspec:GPR [(match_operand:BLK 1 "memory_operand" "m")
 		     (match_operand:QI 2 "memory_operand" "ZC")]
 		    UNSPEC_LOAD_LEFT))]
-  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
+  "!TARGET_MIPS16 && !TARGET_LEXRA && !TARGET_RLX && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
   "<load>l\t%0,%2"
   [(set_attr "move_type" "load")
    (set_attr "mode" "<MODE>")])
@@ -4350,7 +4360,7 @@
 		     (match_operand:QI 2 "memory_operand" "ZC")
 		     (match_operand:GPR 3 "register_operand" "0")]
 		    UNSPEC_LOAD_RIGHT))]
-  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
+  "!TARGET_MIPS16 && !TARGET_LEXRA && !TARGET_RLX && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
   "<load>r\t%0,%2"
   [(set_attr "move_type" "load")
    (set_attr "mode" "<MODE>")])
@@ -4360,7 +4370,7 @@
 	(unspec:BLK [(match_operand:GPR 1 "reg_or_0_operand" "dJ")
 		     (match_operand:QI 2 "memory_operand" "ZC")]
 		    UNSPEC_STORE_LEFT))]
-  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
+  "!TARGET_MIPS16 && !TARGET_LEXRA && !TARGET_RLX && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
   "<store>l\t%z1,%2"
   [(set_attr "move_type" "store")
    (set_attr "mode" "<MODE>")])
@@ -4371,7 +4381,7 @@
 		     (match_operand:QI 2 "memory_operand" "ZC")
 		     (match_dup 0)]
 		    UNSPEC_STORE_RIGHT))]
-  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
+  "!TARGET_MIPS16 && !TARGET_LEXRA && !TARGET_RLX && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
   "<store>r\t%z1,%2"
   [(set_attr "move_type" "store")
    (set_attr "mode" "<MODE>")])
--- a/gcc/config/mips/mips.opt
+++ b/gcc/config/mips/mips.opt
@@ -335,6 +335,14 @@ mpaired-single
 Target Report Mask(PAIRED_SINGLE_FLOAT)
 Use paired-single floating-point instructions.
 
+mlexra
+Target Report Mask(LEXRA)
+Do not use lwl/lwr/swl/swr instructions absent in Lexra chips
+
+mno-bdsl
+Target Report Var(flag_fix_bdsl) Init(0)
+Forbid the use of load instructions in the branch delay slots for all cases
+
 mr10k-cache-barrier=
 Target Joined RejectNegative Enum(mips_r10k_cache_barrier_setting) Var(mips_r10k_cache_barrier) Init(R10K_CACHE_BARRIER_NONE)
 -mr10k-cache-barrier=SETTING	Specify when r10k cache barriers should be inserted.
--- a/gcc/config/mips/mips-tables.opt
+++ b/gcc/config/mips/mips-tables.opt
@@ -696,3 +696,21 @@ Enum(mips_arch_opt_value) String(xlp) Va
 EnumValue
 Enum(mips_arch_opt_value) String(i6400) Value(102) Canonical
 
+EnumValue
+Enum(mips_arch_opt_value) String(lx4180) Value(103) Canonical
+
+EnumValue
+Enum(mips_arch_opt_value) String(rlx4181) Value(104) Canonical
+
+EnumValue
+Enum(mips_arch_opt_value) String(rlx4281) Value(105) Canonical
+
+EnumValue
+Enum(mips_arch_opt_value) String(rlx5181) Value(106) Canonical
+
+EnumValue
+Enum(mips_arch_opt_value) String(lx5280) Value(107) Canonical
+
+EnumValue
+Enum(mips_arch_opt_value) String(rlx5281) Value(108) Canonical
+
